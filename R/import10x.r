#' import10x
#' import 10x data from filtered feature matrices generated by Cell Ranger
#'
#' @param path Accepts either a directory containing compressed 'tsv' files or an 'h5' file.
#' @param type (optional) Force input file type to user input. Supported input types are "ff_bc_matrix" or "h5".
#' @param ESNG Defaults to FALSE. Logical that determines weather gene names should be used or ensembl gene id
#'
#' @importFrom Matrix Matrix readMM sparseMatrix
#' @importFrom hdf5r H5File$new
#' @importFrom utils read.table
#'
#' @return Sparse matrix of 10x single-cell count data. Class dgCMatrix.
#' @export
#'
#' @examples
#' path_to_file <- '/path/to/data'
#' data <- import10x(path_to_file)
#'
#' path_to_file <- '/path/to/data.h5'
#' data <- import10x(path = path_to_file, ESNG = T)
import10x <- function(path, type = "unspecified", ESNG = F){
  supported_file_types <- c("ff_bc_matrix", "h5")
  ptm <- proc.time() #set time start

####Define sub routines#########################################################

  ##subRoutine##
  #compile_dgCMatrix#
  compile_dgCMatrix <- function(tables.list) { #formatting function for dgCMatrices

    if(inherits(tables.list[["barcodes"]], "data.frame") == T){ #check if barcodes are data.frame and coerce to character vector
      tables.list[["barcodes"]] <- tables.list[["barcodes"]][,1]
    }

    data <- Matrix::Matrix(tables.list[["matrix"]] ,  # define dim names and ensure format
                           sparse = T ,
                           dimnames = list(tables.list[["features"]],
                                           tables.list[["barcodes"]]) ,
                           forceCheck = T,
                           doDiag = F)
    data <- as(data, Class = "dgCMatrix") # cast from 'T' to 'C' representation
  }

  ##subRoutine##
  #Check_for_file_exceptions#
  check_file_exceptions <- function(path, type) { #format and detect file type

    path <- file.path(path)

    if(!file.exists(path)){return(stop("file not found"))}

    if(!(type %in% supported_file_types)){  #check if type specified. if not, attempt to detect
      type <- strsplit(basename(path), split = "\\.")
      if(length(type[[1]]) == 1){ #check if has extension. if not assume directory.
        if(!dir_contains_ffbcmat(path)){stop("could not find files in directory")}
        type[[1]] <- path
        type[[2]] <- "ff_bc_matrix"
        return(type)
      }else if(type[[1]][length(type[[1]])] == 'h5'){ #check if extension is '.h5' and set type
        type[[2]] <- type[[1]][length(type[[1]])]
        type[[1]] <- path
        return(type)
      }else{ #any other file extension is unsupported
        try(type <- type[[1]][length(type[[1]])])
      }
    }else if(type %in% supported_file_types){ #check if specified type is accepted
      usr_def_type <- list()
      usr_def_type[[1]] <- path
      usr_def_type[[2]] <- type
      return(usr_def_type)
    }
    try(message((paste("specified file type '.", type, "' not recognized", sep = ''))))
    return(stop("invalid file or file type", call. = F))
  }

  ##subRoutine##
  #dir_contains_ffbcmat#
  dir_contains_ffbcmat <- function(path){      #check folder contents for subfiles of ff_bc_matrix

    cat("searching directory for associated files \n")
    dir.contents <- strsplit(dir(path), split = "\\.")
    components <- c("barcodes", "features", "matrix")
    recognized <- c(F, F, F)

    if(all(lengths(dir.contents) <= 1)){  #throw exception if files don't have extensions
      return(stop("path contains only directories or files without recognizeable extensions"))
    }

    for(i in 1:length(dir.contents)){
      recognized <- components %in% dir.contents[[i]] | recognized
    }

    cat(paste("location contains", + length(dir.contents), "files \n"))

    return(all(recognized))
  }

  dimnames_make_unique <- function(data_10x){ #checks imported matrix for duplicate dimnames. makes gene symbols unique
    if(any(duplicated(dimnames(data_10x)[[2]]))){
      warning("duplicate UMI's found in data set ") #Does not alter UMIs, but warns the user
    }

    dupes <- duplicated(dimnames(data_10x)[[1]]) #TODO!!! HANDLE DUPLICATE GENE SYMBOLS
    if(any(dupes)){
      if(verbose = T){
        warning("duplicate gene symbols in data set")
        message("Unique names will automatically be generated for all duplicates")
      }

      #pseudo-code for recursively enumerating duplicates

      # function(count = 0)
      #   count = count ++
      #   if has duplicates
      #     locate all duplicate values
      #     change all duplicate values to value.count
      #     function(count)
      #   else return
      #

        #dupes <- dimnames(data_10x)[[1]][dupes] #recursively enumerate duplicates.
        #for(symbol in dupes){
          #match(symbol, dimnames(data_10x)[[1]])
        #}
    }
  }

####allocate fun vars###########################################################
  tables.list <- list()
  type <- check_file_exceptions(path, type) #appropriately handle user input for type and path
  path <- type[[1]] # resets path to platform independent output from check_file_exceptions()


  cat(paste("format:", type[[2]], "\n")) #print detected file type
####main flow control switch for type specific importing########################
  data_10x <- switch(type[[2]],
                 "ff_bc_matrix" = { ############################################

                   #import files as elements of a list
                   cat("importing data from file: \n")
                   for(set in dir(path)){
                     cat(paste(set, "\n"))
                     table.index <- substr(set, 0, nchar(set)-7)
                     if(substr(set, nchar(set)-5, nchar(set)-3) == "tsv"){
                       tables.list[[table.index]] <- read.table(file.path(path, set))
                    }else{
                      message("Large matrices may take a minute to process...")
                      tables.list[[table.index]]<- Matrix::readMM(file = file.path(path, set))
                      }
                   }
                   if(ESNG == T){tables.list[["features"]] <- tables.list[["features"]][,1]}else{
                     tables.list[["features"]] <- tables.list[["features"]][,2]
                   }

                   compile_dgCMatrix(tables.list) #compile imported files into a single dgCMatrix by index
                 },
                 "h5" = { ######################################################
                   #import data from h5
                   activeFile <- hdf5r::H5File$new(filename =  path, mode = 'r')
                   activeFile.datasets <- names(activeFile)
                   #support for v3 (no multimodal support)
                   if(length(activeFile.datasets) > 1){stop("h5 files with multiple datasets not supported")}

                   data <- activeFile[[activeFile.datasets]]
                   data.attrs <- names(data)
                   if(ESNG == T){data.attrs[data.attrs == "features"] <- "features/id"}else{
                     data.attrs[data.attrs == "features"]<- "features/name"
                   }
                   cat("importing data from h5: \n")
                   for(set in data.attrs){
                     cat(paste(set, "\n"))
                     tables.list[[set]] <- data[[set]][]
                   }

                   names(tables.list)[grep("features", names(tables.list))] <- "features"

                   tables.list[["matrix"]] <- Matrix::sparseMatrix(
                     i = tables.list[["indices"]] + 1,
                     p = tables.list[["indptr"]],
                     x = tables.list[["data"]],
                     dims = tables.list[["shape"]],
                     repr = "T")

                   activeFile$close_all()

                   compile_dgCMatrix(tables.list)
                 }
                 )

  cat("Done. \n time ")
  print((proc.time() - ptm)[3]) #print time elapsed


  return(data_10x)
}

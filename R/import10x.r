#' import10x
#' import 10x data from filtered feature matrices generated by Cell Ranger
#'
#' @param path Accepts either a directory containing compressed 'tsv' files or an 'h5' file.
#' @param type (optional) Type of file. Either "ff_bc_matrix" or "h5".
#' @param ESNG Defaults to FALSE. Logical that determines weather gene names should be used or ensembl gene id
#'
#' @importFrom Matrix Matrix readMM sparseMatrix
#' @importFrom hdf5r H5File$new
#' @importFrom utils read.table
#'
#' @return Sparse matrix of 10x single-cell count data. Class dgCMatrix.
#' @export
#'
#' @examples
#' path_to_file <- '/path/to/data'
#' data <- import10x(path_to_file)
#'
#' path_to_file <- '/path/to/data.h5'
#' data <- import10x(path = path_to_file, ESNG = T)
import10x <- function(path, type = "unspecified", ESNG = F){ #TODO! enable ESNG for h5 files
  supported_file_types <- c("ff_bc_matrix", "h5")
  ptm <- proc.time() #set time start

####Define sub routines#########################################################
  #compile_dgCMatrix#
  compile_dgCMatrix <- function(tables.list) { #formatting function for dgCMatrices

    if(inherits(tables.list[["barcodes"]], "data.frame") == T){ #check if barcodes are data.frame and coerce to character vector
      tables.list[["barcodes"]] <- tables.list[["barcodes"]][,1]
    }

    data <- Matrix::Matrix(tables.list[["matrix"]] ,  # define dim names and ensure format
                           sparse = T ,
                           dimnames = list(tables.list[["features"]],
                                           tables.list[["barcodes"]]) ,
                           forceCheck = T,
                           doDiag = F)
    data <- as(data, Class = "dgCMatrix") # cast from 'T' to 'C' representation
  }

  #Check_for_file_exceptions#
  check_file_exceptions <- function(path, type) { #format and detect file type

    path <- file.path(path)

    if(!file.exists(path)){return(stop("file not found"))}

    if(!(type %in% supported_file_types)){  #check if type specified. if not, attempt to detect
      type <- strsplit(basename(path), split = "\\.")
      if(length(type[[1]]) == 1){ #check if has extension. if not assume directory.
        cat(paste("directory containing", + length(dir(path)), "files \n")) ##TODO! check if all required files are present
        type[[1]] <- path
        type[[2]] <- "ff_bc_matrix"
        return(type)
      }else if(type[[1]][length(type[[1]])] == 'h5'){ #check if extension is '.h5' and set type
        type[[2]] <- type[[1]][length(type[[1]])]
        type[[1]] <- path
        return(type)
      }else{ #any other file extension is unsupported
        try(type <- type[[1]][length(type[[1]])])
      }
    }else if(type %in% supported_file_types){ #check if specified type is accepted
      usr_def_type <- list() #TODO! handle user input mismatch
      usr_def_type[[1]] <- path
      usr_def_type[[2]] <- type
      return(usr_def_type)
    }
    try(message((paste("specified file type '.", type, "' not recognized", sep = ''))))
    return(stop("invalid file or file type", call. = F))
  }


  # # dir_contains_matrix <- function(){}
  #
  #
  #
  # function that ensures ff_bc_matrix folder contains all required elements

####allocate fun vars###########################################################
  tables.list <- list()
  type <- check_file_exceptions(path, type) #appropriately handle user input for type and path
  path <- type[[1]] # resets path to platform independent output from check_file_exceptions()


  cat(paste("file type:", type[[2]], "\n")) #print detected file type
####main flow control switch for type specific importing########################
  data_10x <- switch(type[[2]],
                 "ff_bc_matrix" = { ############################################

                   #import files as elements of a list
                   cat("importing data from file: \n")
                   for(set in dir(path)){
                     cat(paste(set, "\n"))
                     table.index <- substr(set, 0, nchar(set)-7)
                     if(substr(set, nchar(set)-5, nchar(set)-3) == "tsv"){
                       tables.list[[table.index]] <- read.table(file.path(path, set))
                    }else{
                      message("Large matrices may take a minute to load...")
                      tables.list[[table.index]]<- Matrix::readMM(file = file.path(path, set))
                      }
                   }
                   if(ESNG == T){tables.list[["features"]] <- tables.list[["features"]][,1]}else{
                     tables.list[["features"]] <- tables.list[["features"]][,2]
                   }

                   compile_dgCMatrix(tables.list) #compile imported files into a single dgCMatrix by index
                 },
                 "h5" = { ######################################################
                   #import data from h5
                   activeFile <- hdf5r::H5File$new(filename =  path, mode = 'r')
                   activeFile.datasets <- names(activeFile)
                   #support for v3 (no multimodal support)
                   if(length(activeFile.datasets) > 1){stop("h5 files with multiple datasets not supported")}

                   data <- activeFile[[activeFile.datasets]]
                   data.attrs <- names(data)
                   if(ESNG == T){data.attrs[data.attrs == "features"] <- "features/id"}else{
                     data.attrs[data.attrs == "features"]<- "features/name"
                   }
                   cat("importing data from h5: \n")
                   for(set in data.attrs){
                     cat(paste(set, "\n"))
                     try(tables.list[[set]] <- data[[set]][])
                   }

                   tables.list[["matrix"]] <- Matrix::sparseMatrix(
                     i = tables.list[["indices"]] + 1,
                     p = tables.list[["indptr"]],
                     x = tables.list[["data"]],
                     dims = tables.list[["shape"]],
                     repr = "T")

                   activeFile$close_all()

                   compile_dgCMatrix(tables.list)
                 }
                 )

  cat("Done. \n time ")
  print((proc.time() - ptm)[3]) #print time elapsed

  return(data_10x)
}


#' check_matrices
#'
#'rudimentary checking of equivalency between sparse matrices of class dgCMatrix.
#'provides breakdown by elements
#' @param frame1 matrix 1
#' @param frame2 matrix 2
#'
#'
check_matrices <- function(frame1, frame2){
  print("i")
  print(identical(frame1@i, frame2@i))
  print("p")
  print(identical(frame1@p, frame2@p))
  print("Dim")
  print(identical(frame1@Dim, frame2@Dim))
  print("x")
  print(identical(frame1@x, frame2@x))
  print("Dimnames 1, 2")
  print(identical(frame1@Dimnames[[1]], frame2@Dimnames[[1]]))
  print(identical(frame1@Dimnames[[2]], frame2@Dimnames[[2]]))
  print("factors")
  print(identical(frame1@factors, frame2@factors))
}


